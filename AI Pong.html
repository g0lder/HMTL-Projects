<!DOCTYPE html>
<html>
<head>
  <title>AI Breakout</title>
  <meta charset="UTF-8">
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }
    body {
      background: black;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    canvas {
      border: 1px solid white;
    }
  </style>
</head>

<body>
<canvas width="400" height="500" id="game"></canvas>
<script>
  const canvas = document.getElementById('game');
  const context = canvas.getContext('2d');

  function saveBrain() {
    if (Object.keys(Q).length > 0) {
        localStorage.setItem("qTable", JSON.stringify(Q));
        console.log("Brain saved!");
    } else {
        console.log("Q-table is empty, nothing to save.");
    }
}

function loadBrain() {
    const savedQTable = localStorage.getItem("qTable");
    try {
        Q = JSON.parse(savedQTable);
        console.log("Brain loaded!");
    } 
    catch(err) {
        console.log("No saved brain found. Starting fresh!");
        Q = {}; // Start with an empty Q-table
    }
}

try {
    loadBrain()
}
catch(err){
    console.log('No brain!')
}
setInterval(saveBrain, 30000); // Auto-save every 30 seconds





  const wallSize = 12;
  const brickWidth = 25;
  const brickHeight = 12;
  const brickGap = 2;

  const level1 = [
    [], [], [], [], [], [],
    ['R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R'],
    ['R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R', 'R'],
    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],
    ['O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O', 'O'],
    ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
    ['G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G', 'G'],
    ['Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y'],
    ['Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y', 'Y']
  ];

  const colorMap = {
    'R': 'red',
    'O': 'orange',
    'G': 'green',
    'Y': 'yellow'
  };

  const bricks = [];
  for (let row = 0; row < level1.length; row++) {
    for (let col = 0; col < level1[row].length; col++) {
      const colorCode = level1[row][col];
      bricks.push({
        x: wallSize + (brickWidth + brickGap) * col,
        y: wallSize + (brickHeight + brickGap) * row,
        color: colorMap[colorCode],
        width: brickWidth,
        height: brickHeight
      });
    }
  }

  const paddle = {
    x: canvas.width / 2 - brickWidth / 2,
    y: canvas.height - 30,
    width: brickWidth * 2,
    height: brickHeight,
    dx: 0
  };

  const ball = {
    x: canvas.width / 2,
    y: canvas.height - 50,
    width: 10,
    height: 10,
    dx: 2,
    dy: -2
  };

  // AI Learning Parameters
  let Q = {};
  const actions = ["left", "right", "stop"];
  const learningRate = 0.1;
  const discountFactor = 0.95;
  let explorationRate = 0.9;

  function getState() {
    let ballX = Math.floor(ball.x / 50);
    let ballY = Math.floor(ball.y / 50);
    let paddleX = Math.floor(paddle.x / 50);
    return `${ballX}-${ballY}-${paddleX}`;
  }

  function chooseAction(state) {
    if (Math.random() < explorationRate || !Q[state]) {
      return actions[Math.floor(Math.random() * actions.length)];
    }
    let maxQ = -Infinity;
    let bestAction = actions[0];
    for (let action of actions) {
      let qValue = Q[state]?.[action] || 0;
      if (qValue > maxQ) {
        maxQ = qValue;
        bestAction = action;
      }
    }
    return bestAction;
  }

  function updateQTable(state, action, reward, nextState) {
  if (!Q[state]) Q[state] = {};
  if (!Q[nextState]) Q[nextState] = {};

  let currentQ = Q[state][action] || 0;
  let maxNextQ = Math.max(...actions.map(a => Q[nextState][a] || 0));

  // Update Q-value using the reward and next state's max Q-value
  Q[state][action] = currentQ + learningRate * (reward + discountFactor * maxNextQ - currentQ);

  // Add small randomization to prevent stagnation
  for (let a of actions) {
    if (!Q[state][a]) Q[state][a] = 0;
    Q[state][a] += Math.random() * 0.01; // Add randomness
  }
}

  function collides(obj1, obj2) {
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
  }

  let lastState = null;
  let lastAction = null;

  function loop() {
  context.clearRect(0, 0, canvas.width, canvas.height);

  // Update paddle position
  paddle.x += paddle.dx;
  if (paddle.x < wallSize) paddle.x = wallSize;
  if (paddle.x + paddle.width > canvas.width - wallSize) paddle.x = canvas.width - wallSize - paddle.width;

  // Update ball position
  ball.x += ball.dx;
  ball.y += ball.dy;

  if (ball.x < wallSize || ball.x + ball.width > canvas.width - wallSize) ball.dx *= -1;
  if (ball.y < wallSize) ball.dy *= -1;
  if (ball.y > canvas.height) {
    ball.x = canvas.width / 2;
    ball.y = canvas.height - 50;
    ball.dx = 2;
    ball.dy = -2;
    updateQTable(lastState, lastAction, -100, getState()); // Penalize ball loss
  }

  // Check collisions with paddle
  if (collides(ball, paddle)) {
    ball.dy *= -1;
    updateQTable(lastState, lastAction, 20, getState()); // Reward hitting the ball
  }

  // Check collisions with bricks
  for (let i = 0; i < bricks.length; i++) {
    if (collides(ball, bricks[i])) {
      ball.dy *= -1;
      bricks.splice(i, 1);
      updateQTable(lastState, lastAction, 25, getState()); // Reward breaking a brick
      break;
    }
  }

  // Draw walls
  context.fillStyle = 'lightgrey';
  context.fillRect(0, 0, canvas.width, wallSize);
  context.fillRect(0, 0, wallSize, canvas.height);
  context.fillRect(canvas.width - wallSize, 0, wallSize, canvas.height);

  // Draw paddle
  context.fillStyle = 'cyan';
  context.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

  // Draw ball
  context.fillStyle = 'white';
  context.fillRect(ball.x, ball.y, ball.width, ball.height);

  // Draw bricks
  for (let brick of bricks) {
    context.fillStyle = brick.color;
    context.fillRect(brick.x, brick.y, brick.width, brick.height);
  }

  // AI chooses action
  let state = getState();
  let action = chooseAction(state);
  if (action === "left") paddle.dx = -3;
  else if (action === "right") paddle.dx = 3;
  else paddle.dx = 0;

  // Reward for keeping the paddle close to the ball horizontally
  const proximityReward = -Math.abs(ball.x - (paddle.x + paddle.width / 2)) * 0.05;

  // Update Q-table
  if (lastState !== null && lastAction !== null) {
    updateQTable(lastState, lastAction, proximityReward, state);
  }
  lastState = state;
  lastAction = action;

  // Reduce exploration rate over time
  explorationRate = Math.max(0.01, explorationRate * 0.999);
  requestAnimationFrame(loop);
}

  loop();
</script>
</body>
</html>
